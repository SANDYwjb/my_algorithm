package com.junbin.algorithm.second.twenty;

/**
 * 72. 编辑距离-困难
 * 给你两个单词 word1 和 word2， 请返回将 word1 转换成 word2 所使用的最少操作数  。
 * <p>
 * 你可以对一个单词进行如下三种操作：
 * 插入一个字符
 * 删除一个字符
 * 替换一个字符
 * <p>
 * 输入：word1 = "horse", word2 = "ros"
 * 输出：3
 * 解释：
 * horse -> rorse (将 'h' 替换为 'r')
 * rorse -> rose (删除 'r')
 * rose -> ros (删除 'e')
 * <p>
 * 动态规划：双指针的方法解决。使用两个指针，分别指向两个字符串的末尾，一步一步缩小解决问题的规模，当两个指针走完这两个字符串时，就能得到结果了
 * 首先，我们要确定基状态，那就是当某一个指针走完字符串时，可以直接返回另一个字符串剩下的长度。
 * 接着，我们要确定其他状态，对于这道题来说，有以下四种操作可以改变状态：
 * 当两个指针指向的字符一致时，只需要同时向前移动指针；
 * 当两个指针指向的字符不一致时，可以执行插入、删除或替换操作
 * 对于两个指针指向的字符一致的情况，很容易解决。但是对于不一致的情况，究竟选择哪种操作才能使编辑距离最小呢？
 * 我们这里可以使用递归操作，分别求执行这三种操作的编辑距离，求这三者之间的最小值即可。
 *
 * @author junbin.wang
 * @date 2023/2/17上午8:02
 */
public class EditDistance {
    public int minDistance(String word1, String word2) {
        // 获取两个字符串长度
        int m = word1.length();
        int n = word2.length();
        // 定义 dp 数组， dp数组中总是要长度+1
        int[][] dp = new int[m + 1][n + 1];
        // 基状态
        for (int i = 1; i <= m; ++i) {
            dp[i][0] = i;
        }
        for (int j = 1; j <= n; ++j) {
            dp[0][j] = j;
        }
        // 循环操作，从1开始，因为动态递归就是求当前值的时候默认已经知道了前面的值
        for (int i = 1; i <= m; ++i) {
            for (int j = 1; j <= n; ++j) {
                // 字符相同的情况不用操作
                if (word1.charAt(i - 1) == word2.charAt(j - 1)) {
                    dp[i][j] = dp[i - 1][j - 1];
                } else {
                    // 字符不同的情况分别执行三种操作取最小值
                    dp[i][j] = Math.min(
                            Math.min(
                                    // 插入操作，直接在 word1[i] 插入一个和 word2[j] 一样的字符，所以 word2[j] 被匹配，指针 j 向前移动，
                                    // 继续和 i 对比，操作数加一
                                    dp[i - 1][j] + 1,
                                    // 删除操作，直接把 word1[i] 这个字符删除，指针 i 向前移动，继续和 j 对比，操作数加一。
                                    dp[i][j - 1] + 1),
                            // dp[i - 1][j - 1]表示替换操作：直接把 word1[i] 这个字符替换成 word2[j] ，
                            // 指针 i 和指针 j 同时向前移动，继续对比，操作数加一
                            dp[i - 1][j - 1] + 1);
                }
            }
        }
        // 返回最小编辑距离
        return dp[m][n];
    }
}
